<!DOCTYPE html>
<!-- ... (head and body tags are the same as the last full version) ... -->
    
    <!-- ADD THIS NEW MODAL to your HTML, inside the body but outside the main container -->
    <div id="cors-modal" class="modal-backdrop fixed inset-0 z-50 flex items-center justify-center p-4 invisible opacity-0">
        <div class="modal-content w-full max-w-md rounded-2xl p-6 transform scale-95 opacity-0">
            <h3 class="text-xl font-semibold mb-4">Advanced Security Detected</h3>
            <p class="text-[var(--text-secondary)] mb-6">This website requires a browser extension to translate. Please enable the <a href="https://chromewebstore.google.com/detail/allow-cors-access-control/lhobafahddgcelffkeicbaginigeejlf" target="_blank" class="underline text-[var(--accent)]">Allow CORS</a> extension, then try again.</p>
            <div class="flex justify-end">
                <button id="cors-modal-close" class="btn-primary px-5 py-2 rounded-lg font-semibold">Got it</button>
            </div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // ... (elements and state are the same as the last full version) ...
        const state = { nav: { next: null, prev: null }, currentUrl: '', isTranslating: false, forceFrontendScraping: false };
        // ... (languageConfig is the same) ...

        async function handleTranslation(url) {
            const cleanedUrl = cleanUrl(url);
            if (!cleanedUrl || state.isTranslating || cleanedUrl === state.currentUrl) return;

            // ... (UI setup logic is the same) ...
            
            try {
                let navLinks;
                if (state.forceFrontendScraping) {
                    console.log("Using Frontend Scraper due to previous block.");
                    navLinks = await translateWithFrontendScraper(cleanedUrl);
                } else {
                    console.log("Using Backend Scraper (Default).");
                    navLinks = await translateWithBackendScraper(cleanedUrl);
                }
                state.nav = { next: navLinks.nextUrl, prev: navLinks.prevUrl };
                updateStatus('Successfully translated chapter.');
                sessionStorage.setItem('nt_lastUrl', state.currentUrl);
            } catch (error) {
                // --- THIS IS THE HYBRID LOGIC ---
                if (error.errorCode === 'FORBIDDEN') {
                    console.log("Backend blocked (403). Switching to frontend mode and prompting user.");
                    state.forceFrontendScraping = true; // Set the flag for next time
                    toggleModal(elements.modals.cors, true); // Show the CORS modal
                    state.currentUrl = ''; // Allow re-trying
                } else {
                    state.currentUrl = ''; // Allow re-trying on other errors
                    updateStatus(error.message);
                }
            } finally {
                // ... (cleanup logic is the same) ...
            }
        }

        async function translateWithBackendScraper(url) {
            const langConfig = languageConfig[elements.langSelect.value];
            const prompt = langConfig.prompt.replace('{{GLOSSARY}}', `${langConfig.defaultGlossary}\n${elements.glossaryTextarea.value}`);

            const response = await fetch('/api/translate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    novelUrl: url, 
                    promptData: prompt, 
                    userApiKey: elements.groqKeyInput.value,
                    cssSelector: elements.cssSelectorInput.value.trim()
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                const error = new Error(errorData.error || 'Translation request failed.');
                if (response.status === 403) error.errorCode = 'FORBIDDEN';
                throw error;
            }
            
            // ... (Stream processing logic is the same as the last full version) ...
            
            return { nextUrl: response.headers.get('X-Next-Url') || null, prevUrl: response.headers.get('X-Prev-Url') || null };
        }

        // --- THIS IS THE RESTORED FRONTEND SCRAPER ---
        async function translateWithFrontendScraper(url) {
            updateStatus('Scraping with browser...');
            const { rawText, chapterTitle, nextUrl, prevUrl } = await scrapeFromBrowser(url);
            
            updateStatus('Translating...');
            const textToTranslate = `${chapterTitle}\n---\n${rawText}`;

            const langConfig = languageConfig[elements.langSelect.value];
            const prompt = langConfig.prompt.replace('{{GLOSSARY}}', `${langConfig.defaultGlossary}\n${elements.glossaryTextarea.value}`).replace('{{TEXT}}', textToTranslate);
            
            // This calls the Groq API directly, which requires the extension
            const groqResponse = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${elements.groqKeyInput.value || 'gsk_...YourFallbackKeyHere'}` },
                body: JSON.stringify({
                    model: 'llama-3.3-70b-versatile',
                    messages: [{ role: 'user', content: prompt }],
                    stream: true, max_tokens: 8000,
                }),
            });

            if (!groqResponse.ok) throw new Error('Groq API request failed. Check your API key and CORS extension.');
            
            // ... (Stream processing logic is the same) ...

            return { nextUrl, prevUrl };
        }

        async function scrapeFromBrowser(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch from browser (Status: ${response.status})`);
                const html = await response.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const selector = elements.cssSelectorInput.value.trim() || '.content';
                const contentElement = doc.querySelector(selector);
                if (!contentElement) throw new Error(`Could not find content with selector '${selector}'.`);
                
                const rawText = contentElement.innerText.trim();
                const chapterTitle = doc.querySelector('h1, h2, .title')?.innerText.trim() || 'Untitled Chapter';
                const nextLink = doc.querySelector("a:is(:contains('下一章'), :contains('Next'))");
                const prevLink = doc.querySelector("a:is(:contains('上一章'), :contains('Previous'))");
                
                const getAbsoluteUrl = (link) => link ? new URL(link.getAttribute('href'), url).href : null;

                return { rawText, chapterTitle, nextUrl: getAbsoluteUrl(nextLink), prevUrl: getAbsoluteUrl(prevLink) };
            } catch (e) {
                if (e instanceof TypeError) throw new Error("Fetch failed. Is your CORS extension enabled?");
                throw e;
            }
        }

        // ... (The rest of the script, including event listeners and save/load functions, is the same) ...
        // Add the new modal's close button to the event listeners
        document.getElementById('cors-modal-close').onclick = () => toggleModal(elements.modals.cors, false);
    });
    </script>
</body>
</html>
